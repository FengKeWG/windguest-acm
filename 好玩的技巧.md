### FT Robot

*   **问题描述**: 给出多次移动距离（可正向或反向），每次都必须移动，判断能否到达目标坐标。

*   **解题思路**:
    1.  **转化目标**: 通过联立方程组，可以推导出达到目标坐标所需的正向移动总距离 `X`。设所有移动距离的绝对值之和为 `S_abs`，目标坐标为 `T`。
        我们知道，最终坐标 `T` 等于正向移动的总距离减去反向移动的总距离。
        同时，正向移动的总距离加上反向移动的总距离等于所有移动距离的绝对值之和 `S_abs`。
        设 `X` 为正向移动总距离，`Y` 为反向移动总距离。
        `X - Y = T`
        `X + Y = S_abs`
        两式相加得到 `2X = T + S_abs`，所以 `X = (T + S_abs) / 2`。
        因此，问题转化为判断能否从给定移动距离中选择一些距离，使其和为 `X`。
    2.  **约束条件**:
        *   `T + S_abs` 必须是偶数 (即 `(s + ty) & 1` 必须为0)，否则无法整除。
        *   `T + S_abs` 必须大于等于0 (即 `s + ty < 0` 不成立)，因为 `X` 不能为负。
    3.  **背包问题**: 这是一个典型的0/1背包问题。我们用一个布尔数组 `g` 来表示是否能凑出某个和。
        *   `g[0] = 1` 表示和为0是可达的。
        *   遍历每个移动距离 `b[i]`，从目标和 `tary` 倒序遍历到 `b[i]`。
        *   `g[j] |= g[j - b[i]]` 表示如果 `j - b[i]` 是可达的，那么 `j` 也是可达的（通过加上 `b[i]`）。

*   **代码片段解析**:

    ```cpp
    // 计算所有移动距离的绝对值之和 s
    for (int i = 1; i <= n; i++)
        s += b[i]; // 这里的b[i]应该是指移动距离的绝对值

    // 检查 (S_abs + 目标坐标) 是否为奇数，如果是，则无法到达
    if ((s + ty) & 1)
    {
        cout << "No\n";
        return 0;
    }

    // 检查 (S_abs + 目标坐标) 是否小于0，如果是，则无法到达
    if (s + ty < 0)
    {
        cout << "No\n";
        return 0;
    }

    // 计算所需的目标正向移动总距离 tary
    int tary = (s + ty) / 2;

    // 初始化背包数组，g[0]表示和为0是可达的
    g[0] = 1;

    // 0/1 背包核心逻辑
    // 遍历每个移动距离 b[i]
    for (int i = 1; i <= n; i++)
        // 从目标和 tary 倒序遍历到 b[i]
        for (int j = tary; j >= b[i]; j--)
            // 如果 g[j - b[i]] 为真，说明 j - b[i] 可达，
            // 那么加上 b[i] 后，j 也就可达了。
            g[j] |= g[j - b[i]];
    ```